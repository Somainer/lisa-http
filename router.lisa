(import! helpers/try)
(import! helpers/pipe-macro)
(import! helpers/match)
(import! response-handler)
(import-env! io-source)
(import! html/tag-maker)

(define (make-router route-fn)
  (define (handle-body-transform body)
    (match body
      (html (when (HtmlElement? html))
        (render-html html))
      (json (when (or (record? json) (list? json)))
        (to-json-string json))
      (data (string data))))
  (define (handle-content-type body context)
    (define content-type (match body
      (html (when (HtmlElement? html))
        "text/html")
      (json (when (or (record? json) (list? json)))
        "application/json")
      (_ "text/plain")))
    (|> context
      .getResponseHeaders
      (.add "Content-Type" content-type)))
  (define (handle-response response context)
    (match response
      ((:ignore) ()) ; Do nothing
      ((:ok resp) 
        (handle-content-type resp context)
        (write-response context (handle-body-transform resp)))
      ((:err exception)
        (handle-content-type exception context)
        (write-response context (handle-body-transform exception) 500))
      (((:err code) msg) (when (number? code))
        (handle-content-type msg context)
        (write-response context (handle-body-transform msg) code))
      (fn (when (callable? fn)) (fn context))
      (data ; assume ok.
        (handle-content-type data context)
        (write-response context (handle-body-transform data)))))
  (define (router 'to-string) $"Router(${route-fn})")
  (define (router context (when (has-response? context))) ())
  (define (router context)
    (define path (|> context .getRequestURI .getPath))
    ; (println! $"Path: $path resp: ${(route-fn path context)}")
    (try!
      (let ((result (route-fn path context)))
        (handle-response result context))
      (catch exception
        (handle-response (list :err (.getMessage exception)) context)))
    (if (not (has-response? context))
      (write-response context "404 Not Found" 404)))
  router)

(define-macro (make-routes! ...routes)
  (define (is-http-method? meth)
    (match (.toLowerCase (string meth))
      ("get" true)
      ("post" true)
      ("delete" true)
      ("put" true)
      ("head" true)
      (_ false)))
  (define (method-eql? method context)
    (= (.toUpperCase (string method)) (.getRequestMethod context)))
  (define (handle-route (method path 'when condition ...actions) (when (is-http-method? method)))
    `'(lambda (~path context (when (and (~method-eql? ~(string method) context) ~condition))) ~...actions))
  (define (handle-route (method path ...actions) (when (is-http-method? method)))
    `'(lambda (~path context (when (~method-eql? ~(string method) context))) ~...actions))
  (define (handle-route (path 'when condition ...actions))
    `'(lambda (~path context (when ~condition)) ~...actions))
  (define (handle-route (path ...actions))
    `'(lambda (~path context) ~...actions))
  
  ; (define sym (gen-sym))
  (define sym 'self)
  `'(let ()
      ~...(map routes 
        (lambda (route)
          (define body (handle-route route))
          `'(define ~sym ~body)))
      (define (~sym _ _) '(:ignore))
      ~sym))

(define (chain-routes route) route)
(define (chain-routes route-a route-b)
  (define (router-impl route context)
    (match (route-a route context)
      ((:ignore) (route-b route context))
      (result result)))
  (define (router-impl ...) (panic! "Invalid arguments."))
  router-impl)
(define (chain-routes a b ...rest)
  (chain-routes (chain-routes a b) ...rest))

(define (set-router server prefix router)
  (->> server
    (.createContext prefix (make-handler router))))
(define (set-router server router)
  (set-router server "/" router))
